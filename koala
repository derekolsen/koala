#!/bin/bash

# Check for environment-informed chromium binary or otherwise set one
# This can be modified for your use-case
[ -z "$chrome" ] && chrome="chromium"

destination_array=()
stderr="/dev/null"

# Get options
while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do case $1 in
  -v | --verbose )
    stderr="/dev/stdout"
    ;;
esac; shift; done
if [[ "$1" == '--' ]]; then shift; fi

_end() {
    # Inform console as to why we're terminating
    [[ -z $1 ]] && echo -e "\e[31mTerminating normally\e[0m" && exit 0
    [[ $1 == 1 ]] && echo -e "\e[31m$2 is missing required value: $3\e[0m" && exit 1
    [[ $1 == 2 ]] && echo -e "\e[31m$2 contains a duplicate destination.\e[0m" && exit 2
}

_exit() {
    # Kill all child processes on exit
    jobs="$(jobs -p)"; [ -n "$jobs" ] && kill $jobs
}

# Trap interrupts and exits
trap _end INT
trap _exit EXIT

newline_check() {
    # Boolean of whether a file ends with a newline
    [[ $(tail -c1 "$1" | wc -l) -gt 0 ]]
}

create_stream() {
    # Find an unused display server number
    local Xdisplay=1000
    while [ -f /tmp/.X${Xdisplay}-lock ]; do
        ((Xdisplay+=1))
    done

    # Initialize sane defaults
    local width=1920
    local height=1080
    local colordepth=24
    local framerate=30
    local bitrate=6000

    # Parse config
    while read line; do
        # skip empty lines
        [ -z "$line" ] && continue
        # ignore comments
        [[ $line == \#* ]] && continue
        local "$line"
    done < "$1"

    # Check for required stream variables
    [[ -z "$name" ]] && _end 1 $1 name
    [[ -z "$webpage" ]] && _end 1 $1 webpage
    [[ -z "$destination" ]] && _end 1 $1 destination

    # Check for duplicate destinations
    for i in ${destination_array[@]}; do
        [ $i == $destination ] && _end 2 $1
    done
    destination_array+=($destination)

    # Create a new virtual X server
    Xvfb :${Xdisplay} -screen 0 ${width}x${height}x${colordepth} &
    until [ -f /tmp/.X${Xdisplay}-lock ]; do
        sleep .01s
    done

    # Start chromium
    DISPLAY=:$Xdisplay ${chrome} \
        --user-data-dir=$(mktemp -d) \
        --kiosk \
        --fullscreen \
        --window-position=0,0 \
        --window-size=${width},${height} \
        ${webpage} 2> $stderr &

    # Start ffmpeg
    ffmpeg \
        -video_size ${width}x${height} \
        -y \
        -r ${framerate} \
        -f x11grab \
        -draw_mouse 0 \
        -s ${width}x${height} \
        -i :${Xdisplay} \
        -b:v ${bitrate}k \
        -f mpegts \
        udp://${destination} 2> $stderr &

    # Console output
    echo -e "\e[36m[${name}]: \e[0mStreaming to \e[34mudp://${destination}\e[0m @ \e[33m${width}x${height}x${colordepth}\e[0m (:${Xdisplay})"
    echo -e "URL: \e[32m${webpage}\e[0m"
}

# Run create_stream for each file in streams directory
for stream in streams/*; do
    if ! newline_check "$stream"; then
        echo "" >> "$stream"
    fi
    create_stream "$stream"
done

# Keep main process running
wait
